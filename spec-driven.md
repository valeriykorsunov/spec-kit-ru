# Разработка на основе спецификаций (Spec-Driven Development — SDD)

## Инверсия силы

Десятилетиями код был королем. Спецификации служили коду — они были строительными лесами, которые мы возводили, а затем отбрасывали, как только начиналась "настоящая работа" по написанию кода. Мы писали PRD для руководства разработкой, создавали проектную документацию для информирования реализации, рисовали диаграммы для визуализации архитектуры. Но все это всегда было подчинено самому коду. Код был истиной. Все остальное было, в лучшем случае, благими намерениями. Код был источником истины, и по мере его развития спецификации редко поспевали за ним. Поскольку актив (код) и реализация едины, непросто иметь параллельную реализацию, не пытаясь строить от кода.

Разработка на основе спецификаций (SDD) переворачивает эту структуру власти. Спецификации не служат коду — код служит спецификациям. Документ с требованиями к продукту (PRD) — это не руководство для реализации; это источник, который генерирует реализацию. Технические планы — это не документы, информирующие кодирование; это точные определения, которые производят код. Это не постепенное улучшение того, как мы создаем программное обеспечение. Это фундаментальное переосмысление того, что движет разработкой.

Разрыв между спецификацией и реализацией преследовал разработку программного обеспечения с момента ее зарождения. Мы пытались преодолеть его с помощью лучшей документации, более детальных требований, более строгих процессов. Эти подходы терпят неудачу, потому что они принимают разрыв как неизбежность. Они пытаются сузить его, но никогда не устраняют полностью. SDD устраняет разрыв, делая спецификации и их конкретные планы реализации, рожденные из спецификации, исполняемыми. Когда спецификации и планы реализации генерируют код, разрыва нет — есть только трансформация.

Эта трансформация теперь возможна, потому что ИИ может понимать и реализовывать сложные спецификации, а также создавать детальные планы реализации. Но "сырая" генерация ИИ без структуры порождает хаос. SDD обеспечивает эту структуру через спецификации и последующие планы реализации, которые являются точными, полными и достаточно недвусмысленными для генерации работающих систем. Спецификация становится основным артефактом. Код становится ее выражением (как реализация из плана реализации) на определенном языке и фреймворке.

В этом новом мире поддержка программного обеспечения означает эволюцию спецификаций. Намерение команды разработчиков выражается на естественном языке ("**разработка, управляемая намерениями**"), проектных активах, основных принципах и других руководствах. **Lingua franca** разработки переходит на более высокий уровень, а код становится подходом "последней мили".

Отладка означает исправление спецификаций и их планов реализации, которые генерируют некорректный код. Рефакторинг означает реструктуризацию для ясности. Весь рабочий процесс разработки реорганизуется вокруг спецификаций как центрального источника истины, с планами реализации и кодом в качестве непрерывно регенерируемого результата. Обновление приложений новыми функциями или создание новой параллельной реализации, поскольку мы творческие существа, означает пересмотр спецификации и создание новых планов реализации. Таким образом, этот процесс представляет собой 0 -> 1, (1', ..), 2, 3, N.

Команда разработчиков фокусируется на своем творчестве, экспериментах и критическом мышлении.

## Рабочий процесс SDD на практике

Рабочий процесс начинается с идеи — часто расплывчатой и неполной. Через итеративный диалог с ИИ эта идея становится всеобъемлющим PRD. ИИ задает уточняющие вопросы, выявляет граничные случаи и помогает определить точные критерии приемки. То, что могло занять дни встреч и документации в традиционной разработке, происходит за часы сфокусированной работы над спецификацией. Это трансформирует традиционный жизненный цикл разработки ПО (SDLC) — требования и проектирование становятся непрерывной деятельностью, а не дискретными фазами. Это поддерживает **командный процесс**, где проверенные командой спецификации выражаются и версионируются, создаются в ветках и сливаются.

Когда менеджер продукта обновляет критерии приемки, планы реализации автоматически отмечают затронутые технические решения. Когда архитектор обнаруживает лучший паттерн, PRD обновляется, отражая новые возможности.

На протяжении всего этого процесса спецификации исследовательские агенты собирают критический контекст. Они исследуют совместимость библиотек, бенчмарки производительности и последствия для безопасности. Организационные ограничения обнаруживаются и применяются автоматически — стандарты баз данных вашей компании, требования к аутентификации и политики развертывания бесшовно интегрируются в каждую спецификацию.

Из PRD ИИ генерирует планы реализации, которые отображают требования на технические решения. Каждый технологический выбор имеет задокументированное обоснование. Каждое архитектурное решение прослеживается до конкретных требований. На протяжении всего этого процесса валидация согласованности непрерывно улучшает качество. ИИ анализирует спецификации на предмет двусмысленности, противоречий и пробелов — не как одноразовый пропускной пункт, а как постоянное уточнение.

Генерация кода начинается, как только спецификации и их планы реализации становятся достаточно стабильными, но они не обязаны быть "завершенными". Ранние генерации могут быть исследовательскими — проверка того, имеет ли спецификация смысл на практике. Доменные концепции становятся моделями данных. Пользовательские истории становятся конечными точками API. Сценарии приемки становятся тестами. Это объединяет разработку и тестирование через спецификацию — тестовые сценарии не пишутся после кода, они являются частью спецификации, которая генерирует как реализацию, так и тесты.

Петля обратной связи простирается за пределы начальной разработки. Производственные метрики и инциденты не просто запускают хотфиксы — они обновляют спецификации для следующей регенерации. Узкие места производительности становятся новыми нефункциональными требованиями. Уязвимости безопасности становятся ограничениями, которые влияют на все будущие генерации. Этот итеративный танец между спецификацией, реализацией и операционной реальностью — это то, где возникает истинное понимание и где традиционный SDLC трансформируется в непрерывную эволюцию.

## Почему SDD важен сейчас

Три тенденции делают SDD не просто возможным, но необходимым:

Во-первых, возможности ИИ достигли порога, когда спецификации на естественном языке могут надежно генерировать работающий код. Речь не идет о замене разработчиков — речь идет об усилении их эффективности путем автоматизации механического перевода спецификации в реализацию. Это может усилить исследование и творчество, легко поддержать "начало заново", а также поддержать добавление, вычитание и критическое мышление.

Во-вторых, сложность программного обеспечения продолжает расти экспоненциально. Современные системы интегрируют десятки сервисов, фреймворков и зависимостей. Поддержание всех этих частей в соответствии с первоначальным намерением через ручные процессы становится все более трудным. SDD обеспечивает систематическое выравнивание через генерацию, управляемую спецификацией. Фреймворки могут эволюционировать, чтобы обеспечивать поддержку "AI-first", а не "human-first", или архитектуру вокруг переиспользуемых компонентов.

В-третьих, темп изменений ускоряется. Требования меняются сегодня гораздо быстрее, чем когда-либо прежде. Пивот (резкая смена курса) больше не является исключением — он ожидаем. Современная разработка продуктов требует быстрой итерации на основе отзывов пользователей, рыночных условий и конкурентного давления. Традиционная разработка рассматривает эти изменения как сбои. Каждый пивот требует ручного распространения изменений через документацию, дизайн и код. Результатом являются либо медленные, осторожные обновления, ограничивающие скорость, либо быстрые, безрассудные изменения, накапливающие технический долг.

SDD может поддержать эксперименты "что-если"/симуляции: "Если нам нужно перереализовать или изменить приложение для продвижения бизнес-потребности продавать больше футболок, как бы мы реализовали и экспериментировали для этого?"

SDD превращает изменения требований из препятствий в нормальный рабочий процесс. Когда спецификации управляют реализацией, пивоты становятся систематическими регенерациями, а не ручными переписываниями. Измените ключевое требование в PRD, и затронутые планы реализации обновятся автоматически. Измените пользовательскую историю, и соответствующие конечные точки API регенерируются. Это не просто о начальной разработке — это о поддержании инженерной скорости через неизбежные изменения.

## Основные принципы

**Спецификации как Lingua Franca**: Спецификация становится основным артефактом. Код становится ее выражением на определенном языке и фреймворке. Поддержка программного обеспечения означает эволюцию спецификаций.

**Исполняемые спецификации**: Спецификации должны быть точными, полными и достаточно недвусмысленными для генерации работающих систем. Это устраняет разрыв между намерением и реализацией.

**Непрерывное уточнение**: Валидация согласованности происходит непрерывно, а не как одноразовый пропускной пункт. ИИ анализирует спецификации на предмет двусмысленности, противоречий и пробелов как постоянный процесс.

**Контекст, основанный на исследованиях**: Исследовательские агенты собирают критический контекст на протяжении всего процесса спецификации, исследуя технические варианты, последствия для производительности и организационные ограничения.

**Двунаправленная обратная связь**: Производственная реальность информирует эволюцию спецификации. Метрики, инциденты и операционные знания становятся входными данными для уточнения спецификации.

**Ветвление для исследования**: Генерация нескольких подходов реализации из одной и той же спецификации для исследования различных целей оптимизации — производительности, поддерживаемости, пользовательского опыта, стоимости.

## Подходы к реализации

Сегодня практика SDD требует сборки существующих инструментов и поддержания дисциплины на протяжении всего процесса. Методологию можно практиковать с помощью:

- ИИ-ассистентов для итеративной разработки спецификаций
- Исследовательских агентов для сбора технического контекста
- Инструментов генерации кода для перевода спецификаций в реализацию
- Систем контроля версий, адаптированных для рабочих процессов "сначала спецификация"
- Проверки согласованности через ИИ-анализ документов спецификации

Ключ в том, чтобы рассматривать спецификации как источник истины, а код — как сгенерированный результат, который служит спецификации, а не наоборот.

## Оптимизация SDD с помощью команд

Методология SDD значительно улучшается благодаря трем мощным командам, которые автоматизируют рабочий процесс спецификация → планирование → постановка задач:

### Команда `/speckit.specify`

Эта команда преобразует простое описание функции (пользовательский запрос) в полную, структурированную спецификацию с автоматическим управлением репозиторием:

1. **Автоматическая нумерация функций**: Сканирует существующие спецификации для определения следующего номера функции (например, 001, 002, 003)
2. **Создание ветки**: Генерирует семантическое имя ветки из вашего описания и создает ее автоматически
3. **Генерация на основе шаблона**: Копирует и настраивает шаблон спецификации функции с вашими требованиями
4. **Структура директорий**: Создает правильную структуру `specs/[branch-name]/` для всех связанных документов

### Команда `/speckit.plan`

Как только спецификация функции существует, эта команда создает всеобъемлющий план реализации:

1. **Анализ спецификации**: Читает и понимает требования функции, пользовательские истории и критерии приемки
2. **Конституционное соответствие**: Обеспечивает согласование с конституцией проекта и архитектурными принципами
3. **Технический перевод**: Преобразует бизнес-требования в техническую архитектуру и детали реализации
4. **Детальная документация**: Генерирует вспомогательные документы для моделей данных, контрактов API и сценариев тестирования
5. **Валидация быстрого старта**: Создает руководство по быстрому старту, фиксирующее ключевые сценарии валидации

### Команда `/speckit.tasks`

После создания плана эта команда анализирует план и связанные проектные документы для генерации исполняемого списка задач:

1. **Входные данные**: Читает `plan.md` (обязательно) и, если присутствуют, `data-model.md`, `contracts/` и `research.md`
2. **Вывод задач**: Преобразует контракты, сущности и сценарии в конкретные задачи
3. **Распараллеливание**: Помечает независимые задачи `[P]` и очерчивает безопасные параллельные группы
4. **Вывод**: Записывает `tasks.md` в директорию функции, готовый к выполнению агентом задач (Task agent)

### Пример: Создание функции чата

Вот как эти команды трансформируют традиционный рабочий процесс разработки:

**Традиционный подход:**

```text
1. Написание PRD в документе (2-3 часа)
2. Создание проектной документации (2-3 часа)
3. Ручная настройка структуры проекта (30 минут)
4. Написание технических спецификаций (3-4 часа)
5. Создание планов тестирования (2 часа)
Итого: ~12 часов работы над документацией
```

**Подход SDD с командами:**

```bash
# Шаг 1: Создание спецификации функции (5 минут)
/speckit.specify Real-time chat system with message history and user presence

# Это автоматически:
# - Создает ветку "003-chat-system"
# - Генерирует specs/003-chat-system/spec.md
# - Заполняет ее структурированными требованиями

# Шаг 2: Генерация плана реализации (5 минут)
/speckit.plan WebSocket for real-time messaging, PostgreSQL for history, Redis for presence

# Шаг 3: Генерация исполняемых задач (5 минут)
/speckit.tasks

# Это автоматически создает:
# - specs/003-chat-system/plan.md
# - specs/003-chat-system/research.md (сравнение библиотек WebSocket)
# - specs/003-chat-system/data-model.md (схемы Message и User)
# - specs/003-chat-system/contracts/ (события WebSocket, конечные точки REST)
# - specs/003-chat-system/quickstart.md (ключевые сценарии валидации)
# - specs/003-chat-system/tasks.md (список задач, полученный из плана)
```

За 15 минут у вас есть:

- Полная спецификация функции с пользовательскими историями и критериями приемки
- Детальный план реализации с выбором технологий и обоснованием
- Контракты API и модели данных, готовые к генерации кода
- Всеобъемлющие сценарии тестирования как для автоматизированного, так и для ручного тестирования
- Все документы правильно версионированы в ветке функции

### Сила структурированной автоматизации

Эти команды не просто экономят время — они обеспечивают последовательность и полноту:

1. **Никаких забытых деталей**: Шаблоны гарантируют, что каждый аспект учтен, от нефункциональных требований до обработки ошибок
2. **Отслеживаемые решения**: Каждый технический выбор ссылается обратно на конкретные требования
3. **Живая документация**: Спецификации остаются синхронизированными с кодом, потому что они генерируют его
4. **Быстрая итерация**: Изменяйте требования и регенерируйте планы за минуты, а не дни

Команды воплощают принципы SDD, рассматривая спецификации как исполняемые артефакты, а не статические документы. Они превращают процесс спецификации из неизбежного зла в движущую силу разработки.

### Качество, управляемое шаблонами: Как структура ограничивает LLM для лучших результатов

Истинная сила этих команд заключается не только в автоматизации, но и в том, как шаблоны направляют поведение LLM к более качественным спецификациям. Шаблоны действуют как сложные промпты, которые ограничивают вывод LLM продуктивными способами:

#### 1. **Предотвращение преждевременных деталей реализации**

Шаблон спецификации функции явно инструктирует:

```text
- ✅ Focus on WHAT users need and WHY
- ❌ Avoid HOW to implement (no tech stack, APIs, code structure)
```

Это ограничение заставляет LLM поддерживать правильные уровни абстракции. Когда LLM может естественно перескочить к "реализовать с использованием React с Redux", шаблон удерживает его сфокусированным на "пользователям нужны обновления их данных в реальном времени". Это разделение гарантирует, что спецификации остаются стабильными, даже если технологии реализации меняются.

#### 2. **Принуждение к явным маркерам неопределенности**

Оба шаблона требуют использования маркеров `[NEEDS CLARIFICATION]`:

```text
When creating this spec from a user prompt:
1. **Mark all ambiguities**: Use [NEEDS CLARIFICATION: specific question]
2. **Don't guess**: If the prompt doesn't specify something, mark it
```

Это предотвращает распространенное поведение LLM делать правдоподобные, но потенциально неверные предположения. Вместо того чтобы гадать, что "система входа" использует аутентификацию по email/паролю, LLM должна пометить это как `[NEEDS CLARIFICATION: auth method not specified - email/password, SSO, OAuth?]`.

#### 3. **Структурированное мышление через чек-листы**

Шаблоны включают всеобъемлющие чек-листы, которые действуют как "юнит-тесты" для спецификации:

```markdown
### Requirement Completeness

- [ ] No [NEEDS CLARIFICATION] markers remain
- [ ] Requirements are testable and unambiguous
- [ ] Success criteria are measurable
```

Эти чек-листы заставляют LLM систематически проверять свой собственный вывод, выявляя пробелы, которые в противном случае могли бы проскользнуть. Это как дать LLM структуру контроля качества.

#### 4. **Конституционное соответствие через ворота (Gates)**

Шаблон плана реализации обеспечивает соблюдение архитектурных принципов через фазовые ворота:

```markdown
### Phase -1: Pre-Implementation Gates

#### Simplicity Gate (Article VII)

- [ ] Using ≤3 projects?
- [ ] No future-proofing?

#### Anti-Abstraction Gate (Article VIII)

- [ ] Using framework directly?
- [ ] Single model representation?
```

Эти ворота предотвращают переусложнение, заставляя LLM явно обосновывать любую сложность. Если ворота не пройдены, LLM должна задокументировать причину в разделе "Complexity Tracking", создавая ответственность за архитектурные решения.

#### 5. **Иерархическое управление деталями**

Шаблоны обеспечивают правильную информационную архитектуру:

```text
**IMPORTANT**: This implementation plan should remain high-level and readable.
Any code samples, detailed algorithms, or extensive technical specifications
must be placed in the appropriate `implementation-details/` file
```

Это предотвращает распространенную проблему, когда спецификации становятся нечитаемыми свалками кода. LLM учится поддерживать соответствующие уровни детализации, извлекая сложность в отдельные файлы, сохраняя при этом навигацию по основному документу.

#### 6. **Мышление "Сначала тесты" (Test-First)**

Шаблон реализации обеспечивает разработку через тестирование:

```text
### File Creation Order
1. Create `contracts/` with API specifications
2. Create test files in order: contract → integration → e2e → unit
3. Create source files to make tests pass
```

Это ограничение порядка гарантирует, что LLM думает о тестируемости и контрактах перед реализацией, что приводит к более надежным и проверяемым спецификациям.

#### 7. **Предотвращение спекулятивных функций**

Шаблоны явно не поощряют спекуляции:

```text
- [ ] No speculative or "might need" features
- [ ] All phases have clear prerequisites and deliverables
```

Это останавливает LLM от добавления функций "хорошо бы иметь", которые усложняют реализацию. Каждая функция должна восходить к конкретной пользовательской истории с четкими критериями приемки.

### Составной эффект

Эти ограничения работают вместе, создавая спецификации, которые являются:

- **Полными**: Чек-листы гарантируют, что ничего не забыто
- **Недвусмысленными**: Принудительные маркеры уточнения подсвечивают неопределенности
- **Тестируемыми**: Мышление test-first встроено в процесс
- **Поддерживаемыми**: Правильные уровни абстракции и иерархия информации
- **Реализуемыми**: Четкие фазы с конкретными результатами

Шаблоны превращают LLM из творческого писателя в дисциплинированного инженера по спецификациям, направляя ее возможности на создание последовательно высококачественных, исполняемых спецификаций, которые действительно управляют разработкой.

## Конституционная основа: Обеспечение архитектурной дисциплины

В основе SDD лежит конституция — набор неизменных принципов, которые управляют тем, как спецификации становятся кодом. Конституция (`memory/constitution.md`) действует как архитектурная ДНК системы, гарантируя, что каждая сгенерированная реализация сохраняет согласованность, простоту и качество.

### Девять статей разработки

Конституция определяет девять статей, которые формируют каждый аспект процесса разработки:

#### Статья I: Принцип Library-First

Каждая функция должна начинаться как отдельная библиотека — без исключений. Это обеспечивает модульный дизайн с самого начала:

```text
Every feature in Specify MUST begin its existence as a standalone library.
No feature shall be implemented directly within application code without
first being abstracted into a reusable library component.
```

Этот принцип гарантирует, что спецификации генерируют модульный, переиспользуемый код, а не монолитные приложения. Когда LLM генерирует план реализации, она должна структурировать функции как библиотеки с четкими границами и минимальными зависимостями.

#### Статья II: Мандат интерфейса CLI

Каждая библиотека должна предоставлять свою функциональность через интерфейс командной строки:

```text
All CLI interfaces MUST:
- Accept text as input (via stdin, arguments, or files)
- Produce text as output (via stdout)
- Support JSON format for structured data exchange
```

Это обеспечивает наблюдаемость и тестируемость. LLM не может скрыть функциональность внутри непрозрачных классов — все должно быть доступно и проверяемо через текстовые интерфейсы.

#### Статья III: Императив Test-First

Самая преобразующая статья — никакого кода до тестов:

```text
This is NON-NEGOTIABLE: All implementation MUST follow strict Test-Driven Development.
No implementation code shall be written before:
1. Unit tests are written
2. Tests are validated and approved by the user
3. Tests are confirmed to FAIL (Red phase)
```

Это полностью переворачивает традиционную генерацию кода ИИ. Вместо того чтобы генерировать код и надеяться, что он работает, LLM должна сначала сгенерировать всеобъемлющие тесты, которые определяют поведение, получить их одобрение и только затем генерировать реализацию.

#### Статьи VII и VIII: Простота и Анти-Абстракция

Эти парные статьи борются с переусложнением:

```text
Section 7.3: Minimal Project Structure
- Maximum 3 projects for initial implementation
- Additional projects require documented justification

Section 8.1: Framework Trust
- Use framework features directly rather than wrapping them
```

Когда LLM может естественно создавать сложные абстракции, эти статьи заставляют ее обосновывать каждый слой сложности. "Ворота фазы -1" шаблона плана реализации напрямую обеспечивают соблюдение этих принципов.

#### Статья IX: Тестирование Integration-First

Приоритет реального тестирования над изолированными юнит-тестами:

```text
Tests MUST use realistic environments:
- Prefer real databases over mocks
- Use actual service instances over stubs
- Contract tests mandatory before implementation
```

Это гарантирует, что сгенерированный код работает на практике, а не только в теории.

### Обеспечение соблюдения конституции через шаблоны

Шаблон плана реализации вводит эти статьи в действие через конкретные контрольные точки:

```markdown
### Phase -1: Pre-Implementation Gates

#### Simplicity Gate (Article VII)

- [ ] Using ≤3 projects?
- [ ] No future-proofing?

#### Anti-Abstraction Gate (Article VIII)

- [ ] Using framework directly?
- [ ] Single model representation?

#### Integration-First Gate (Article IX)

- [ ] Contracts defined?
- [ ] Contract tests written?
```

Эти ворота действуют как проверки времени компиляции для архитектурных принципов. LLM не может продолжить работу, не пройдя ворота или не задокументировав обоснованные исключения в разделе "Complexity Tracking".

### Сила неизменных принципов

Сила конституции заключается в ее неизменности. В то время как детали реализации могут меняться, основные принципы остаются постоянными. Это обеспечивает:

1. **Согласованность во времени**: Код, сгенерированный сегодня, следует тем же принципам, что и код, сгенерированный в следующем году
2. **Согласованность между LLM**: Разные модели ИИ производят архитектурно совместимый код
3. **Архитектурная целостность**: Каждая функция усиливает, а не подрывает дизайн системы
4. **Гарантии качества**: Принципы test-first, library-first и простоты обеспечивают поддерживаемый код

### Конституционная эволюция

Хотя принципы неизменны, их применение может эволюционировать:

```text
Section 4.2: Amendment Process
Modifications to this constitution require:
- Explicit documentation of the rationale for change
- Review and approval by project maintainers
- Backwards compatibility assessment
```

Это позволяет методологии учиться и улучшаться, сохраняя стабильность. Конституция показывает свою собственную эволюцию с датированными поправками, демонстрируя, как принципы могут быть уточнены на основе реального опыта.

### Больше чем правила: Философия разработки

Конституция — это не просто свод правил, это философия, которая формирует то, как LLM думают о генерации кода:

- **Наблюдаемость выше непрозрачности**: Все должно быть проверяемо через интерфейсы CLI
- **Простота выше хитроумия**: Начинайте просто, добавляйте сложность только тогда, когда это доказано необходимостью
- **Интеграция выше изоляции**: Тестируйте в реальных средах, а не в искусственных
- **Модульность выше монолитов**: Каждая функция — это библиотека с четкими границами

Встраивая эти принципы в процесс спецификации и планирования, SDD гарантирует, что сгенерированный код не просто функционален — он поддерживаем, тестируем и архитектурно обоснован. Конституция превращает ИИ из генератора кода в архитектурного партнера, который уважает и усиливает принципы системного дизайна.

## Трансформация

Речь не идет о замене разработчиков или автоматизации творчества. Речь идет об усилении человеческих возможностей путем автоматизации механического перевода. Речь идет о создании плотной петли обратной связи, где спецификации, исследования и код эволюционируют вместе, каждая итерация приносит более глубокое понимание и лучшее согласование между намерением и реализацией.

Разработке программного обеспечения нужны лучшие инструменты для поддержания согласования между намерением и реализацией. SDD предоставляет методологию для достижения этого согласования через исполняемые спецификации, которые генерируют код, а не просто направляют его.
