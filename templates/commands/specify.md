---
description: Создать или обновить спецификацию функции на основе описания на естественном языке.
handoffs: 
  - label: Создать технический план
    agent: speckit.plan
    prompt: Создай план для спецификации. Я разрабатываю...
  - label: Уточнить требования к спецификации
    agent: speckit.clarify
    prompt: Уточни требования к спецификации
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## Ввод пользователя

```text
$ARGUMENTS
```

Вы **ОБЯЗАНЫ** учесть ввод пользователя перед продолжением (если он не пустой).

## План действий

Текст, который пользователь ввел после `/speckit.specify` в инициирующем сообщении, **является** описанием функции. Считайте, что оно всегда доступно в этом разговоре, даже если `{ARGS}` ниже отображается буквально. Не просите пользователя повторить его, если только он не предоставил пустую команду.

На основе этого описания функции выполните следующее:

1. **Сгенерируйте краткое имя** (2-4 слова) для ветки:
   - Проанализируйте описание функции и выделите наиболее значимые ключевые слова
   - Создайте короткое имя из 2-4 слов, отражающее суть функции
   - Используйте формат "действие-существительное", когда это возможно (например, "add-user-auth", "fix-payment-bug")
   - Сохраняйте технические термины и аббревиатуры (OAuth2, API, JWT и т.д.)
   - Делайте его кратким, но достаточно описательным для понимания функции с первого взгляда
   - Примеры:
     - "Я хочу добавить аутентификацию пользователей" → "user-auth"
     - "Реализовать интеграцию OAuth2 для API" → "oauth2-api-integration"
     - "Создать дашборд для аналитики" → "analytics-dashboard"
     - "Исправить баг с таймаутом обработки платежей" → "fix-payment-timeout"

2. **Проверьте наличие существующих веток перед созданием новой**:

   a. Сначала получите все удаленные ветки, чтобы иметь актуальную информацию:

      ```bash
      git fetch --all --prune
      ```

   b. Найдите наибольший номер функции во всех источниках для этого краткого имени (short-name):
      - Удаленные ветки: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - Локальные ветки: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - Директории спецификаций: Проверьте директории, соответствующие `specs/[0-9]+-<short-name>`

   c. Определите следующий доступный номер:
      - Извлеките все номера из всех трех источников
      - Найдите наибольшее число N
      - Используйте N+1 для номера новой ветки

   d. Запустите скрипт `{SCRIPT}` с вычисленным номером и кратким именем:
      - Передайте `--number N+1` и `--short-name "ваше-краткое-имя"` вместе с описанием функции
      - Пример для Bash: `{SCRIPT} --json --number 5 --short-name "user-auth" "Добавить аутентификацию пользователей"`
      - Пример для PowerShell: `{SCRIPT} -Json -Number 5 -ShortName "user-auth" "Добавить аутентификацию пользователей"`

   **ВАЖНО**:
   - Проверьте все три источника (удаленные ветки, локальные ветки, директории спецификаций), чтобы найти наибольший номер
   - Ищите совпадения только с точным шаблоном краткого имени
   - Если существующих веток/директорий с таким кратким именем не найдено, начните с номера 1
   - Вы должны запускать этот скрипт только один раз для каждой функции
   - JSON предоставляется в терминале как вывод - всегда обращайтесь к нему, чтобы получить актуальный контент, который вы ищете
   - Вывод JSON будет содержать пути BRANCH_NAME и SPEC_FILE
   - Для одинарных кавычек в аргументах используйте экранирование: например, 'I'\''m Groot' (или двойные кавычки, если возможно: "I'm Groot")

3. Загрузите `templates/spec-template.md`, чтобы понять требуемые разделы.

4. Следуйте этому потоку выполнения:

    1. Распарсите описание пользователя из Ввода
       Если пусто: ОШИБКА "Описание функции не предоставлено"
    2. Выделите ключевые концепции из описания
       Определите: действующих лиц, действия, данные, ограничения
    3. Для неясных аспектов:
       - Сделайте обоснованные предположения на основе контекста и отраслевых стандартов
       - Используйте маркер [NEEDS CLARIFICATION: конкретный вопрос] только если:
         - Выбор существенно влияет на объем функции или пользовательский опыт
         - Существует несколько разумных интерпретаций с различными последствиями
         - Нет разумного значения по умолчанию
       - **ЛИМИТ: Максимум 3 маркера [NEEDS CLARIFICATION] всего**
       - Приоритизируйте уточнения по влиянию: объем > безопасность/конфиденциальность > пользовательский опыт > технические детали
    4. Заполните раздел Пользовательские сценарии и Тестирование (User Scenarios & Testing)
       Если пользовательский поток не ясен: ОШИБКА "Невозможно определить пользовательские сценарии"
    5. Сгенерируйте Функциональные требования (Functional Requirements)
       Каждое требование должно быть тестируемым
       Используйте разумные значения по умолчанию для неуказанных деталей (задокументируйте предположения в разделе Assumptions)
    6. Определите Критерии успеха (Success Criteria)
       Создайте измеримые, технологически независимые результаты
       Включите как количественные метрики (время, производительность, объем), так и качественные меры (удовлетворенность пользователей, завершение задач)
       Каждый критерий должен быть проверяемым без деталей реализации
    7. Определите Ключевые сущности (Key Entities) (если задействованы данные)
    8. Возврат: УСПЕХ (спецификация готова к планированию)

5. Запишите спецификацию в SPEC_FILE, используя структуру шаблона, заменяя заполнители конкретными деталями, полученными из описания функции (аргументов), сохраняя порядок разделов и заголовки. **Пишите спецификацию на русском языке.**

6. **Валидация качества спецификации**: После написания начальной спецификации, проверьте ее по критериям качества:

   a. **Создайте Чек-лист качества спецификации**: Создайте файл чек-листа по пути `FEATURE_DIR/checklists/requirements.md`, используя структуру шаблона чек-листа со следующими пунктами валидации:

      ```markdown
      # Чек-лист качества спецификации: [НАЗВАНИЕ ФУНКЦИИ]
      
      **Цель**: Проверить полноту и качество спецификации перед переходом к планированию
      **Создано**: [ДАТА]
      **Функция**: [Ссылка на spec.md]
      
      ## Качество контента
      
      - [ ] Нет деталей реализации (языки, фреймворки, API)
      - [ ] Сфокусировано на ценности для пользователя и потребностях бизнеса
      - [ ] Написано для нетехнических стейкхолдеров
      - [ ] Все обязательные разделы заполнены
      
      ## Полнота требований
      
      - [ ] Не осталось маркеров [NEEDS CLARIFICATION]
      - [ ] Требования тестируемы и однозначны
      - [ ] Критерии успеха измеримы
      - [ ] Критерии успеха технологически независимы (нет деталей реализации)
      - [ ] Все сценарии приемки определены
      - [ ] Пограничные случаи (edge cases) идентифицированы
      - [ ] Границы (Scope) четко очерчены
      - [ ] Зависимости и предположения идентифицированы
      
      ## Готовность функции
      
      - [ ] Все функциональные требования имеют четкие критерии приемки
      - [ ] Пользовательские сценарии покрывают основные потоки
      - [ ] Функция соответствует измеримым результатам, определенным в Критериях успеха
      - [ ] Детали реализации не просочились в спецификацию
      
      ## Заметки
      
      - Пункты, отмеченные как невыполненные, требуют обновления спецификации перед `/speckit.clarify` или `/speckit.plan`
      ```

   b. **Запустите проверку валидации**: Проверьте спецификацию по каждому пункту чек-листа:
      - Для каждого пункта определите, пройден он или нет
      - Задокументируйте конкретные найденные проблемы (процитируйте соответствующие разделы спецификации)

   c. **Обработка результатов валидации**:

      - **Если все пункты пройдены**: Отметьте чек-лист как завершенный и переходите к шагу 6

      - **Если есть непройденные пункты (исключая [NEEDS CLARIFICATION])**:
        1. Перечислите непройденные пункты и конкретные проблемы
        2. Обновите спецификацию, чтобы устранить каждую проблему
        3. Повторно запустите валидацию, пока все пункты не будут пройдены (максимум 3 итерации)
        4. Если после 3 итераций все еще есть ошибки, задокументируйте оставшиеся проблемы в заметках чек-листа и предупредите пользователя

      - **Если остались маркеры [NEEDS CLARIFICATION]**:
        1. Извлеките все маркеры [NEEDS CLARIFICATION: ...] из спецификации
        2. **ПРОВЕРКА ЛИМИТА**: Если существует более 3 маркеров, оставьте только 3 наиболее критичных (по влиянию на объем/безопасность/UX) и сделайте обоснованные предположения для остальных
        3. Для каждого требуемого уточнения (максимум 3), предложите варианты пользователю в следующем формате:

           ```markdown
           ## Вопрос [N]: [Тема]
           
           **Контекст**: [Цитата соответствующего раздела спецификации]
           
           **Что нам нужно знать**: [Конкретный вопрос из маркера NEEDS CLARIFICATION]
           
           **Предлагаемые ответы**:
           
           | Вариант | Ответ | Последствия |
           |---------|-------|-------------|
           | A       | [Первый предлагаемый ответ] | [Что это значит для функции] |
           | B       | [Второй предлагаемый ответ] | [Что это значит для функции] |
           | C       | [Третий предлагаемый ответ] | [Что это значит для функции] |
           | Custom  | Ваш собственный ответ | [Объясните, как предоставить свой ввод] |
           
           **Ваш выбор**: _[Ждите ответа пользователя]_
           ```

        4. **КРИТИЧНО - Форматирование таблицы**: Убедитесь, что markdown таблицы отформатированы правильно:
           - Используйте последовательные отступы с выровненными разделителями
           - В каждой ячейке должны быть пробелы вокруг содержимого: `| Content |` а не `|Content|`
           - Разделитель заголовка должен иметь как минимум 3 дефиса: `|--------|`
           - Проверьте, что таблица корректно отображается в превью markdown
        5. Нумеруйте вопросы последовательно (Q1, Q2, Q3 - максимум 3 всего)
        6. Представьте все вопросы вместе перед ожиданием ответов
        7. Ждите, пока пользователь ответит своим выбором для всех вопросов (например, "Q1: A, Q2: Custom - [детали], Q3: B")
        8. Обновите спецификацию, заменив каждый маркер [NEEDS CLARIFICATION] на выбранный или предоставленный пользователем ответ
        9. Повторно запустите валидацию после разрешения всех уточнений

   d. **Обновите Чек-лист**: После каждой итерации валидации обновляйте файл чек-листа с текущим статусом прохождения/непрохождения

7. Сообщите о завершении, указав имя ветки, путь к файлу спецификации, результаты чек-листа и готовность к следующему этапу (`/speckit.clarify` или `/speckit.plan`).

**ПРИМЕЧАНИЕ:** Скрипт создает и переключается на новую ветку и инициализирует файл спецификации перед записью.

## Общие рекомендации

## Краткие рекомендации

- Фокусируйтесь на том, **ЧТО** нужно пользователям и **ПОЧЕМУ**.
- Избегайте **КАК** это реализовать (никакого техстека, API, структуры кода).
- Пишите для бизнес-стейкхолдеров, а не разработчиков.
- НЕ создавайте никаких чек-листов, встроенных в спецификацию. Это будет отдельная команда.

### Требования к разделам

- **Обязательные разделы**: Должны быть заполнены для каждой функции
- **Опциональные разделы**: Включайте только если они актуальны для функции
- Если раздел не применим, удалите его полностью (не оставляйте как "N/A")

### Для генерации ИИ

При создании этой спецификации из пользовательского промпта:

1. **Делайте обоснованные предположения**: Используйте контекст, отраслевые стандарты и общие паттерны для заполнения пробелов
2. **Документируйте предположения**: Записывайте разумные значения по умолчанию в разделе Assumptions
3. **Ограничивайте уточнения**: Максимум 3 маркера [NEEDS CLARIFICATION] - используйте только для критических решений, которые:
   - Существенно влияют на объем функции или пользовательский опыт
   - Имеют несколько разумных интерпретаций с различными последствиями
   - Не имеют разумного значения по умолчанию
4. **Приоритизируйте уточнения**: объем > безопасность/конфиденциальность > пользовательский опыт > технические детали
5. **Думайте как тестировщик**: Каждое расплывчатое требование должно проваливать пункт чек-листа "тестируемо и однозначно"
6. **Общие области, требующие уточнения** (только если нет разумного значения по умолчанию):
   - Границы функции и область действия (включение/исключение конкретных сценариев использования)
   - Типы пользователей и права доступа (если возможны множественные противоречивые интерпретации)
   - Требования безопасности/соответствия (когда это юридически/финансово значимо)

**Примеры разумных значений по умолчанию** (не спрашивайте об этом):

- Хранение данных: Стандартные отраслевые практики для домена
- Цели производительности: Стандартные ожидания для веб/мобильных приложений, если не указано иное
- Обработка ошибок: Дружелюбные сообщения для пользователя с соответствующими фоллбеками
- Метод аутентификации: Стандартный на основе сессий или OAuth2 для веб-приложений
- Паттерны интеграции: RESTful API, если не указано иное

### Рекомендации по Критериям успеха

Критерии успеха должны быть:

1. **Измеримыми**: Включать конкретные метрики (время, процент, количество, частота)
2. **Технологически независимыми**: Никаких упоминаний фреймворков, языков, баз данных или инструментов
3. **Ориентированными на пользователя**: Описывать результаты с точки зрения пользователя/бизнеса, а не внутренних систем
4. **Проверяемыми**: Могут быть протестированы/валидированы без знания деталей реализации

**Хорошие примеры**:

- "Пользователи могут завершить оформление заказа менее чем за 3 минуты"
- "Система поддерживает 10,000 одновременных пользователей"
- "95% поисковых запросов возвращают результаты менее чем за 1 секунду"
- "Коэффициент завершения задач улучшается на 40%"

**Плохие примеры** (сфокусированы на реализации):

- "Время ответа API менее 200мс" (слишком технически, используйте "Пользователи видят результаты мгновенно")
- "База данных может обрабатывать 1000 TPS" (деталь реализации, используйте метрику для пользователя)
- "Компоненты React рендерятся эффективно" (специфично для фреймворка)
- "Redis cache hit rate выше 80%" (специфично для технологии)
